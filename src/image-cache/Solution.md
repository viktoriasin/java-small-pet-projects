# Техническое описание итоговой архитектуры трехуровневого кэша
Разработанная архитектура трехуровневого кэша основана на подходе, включающем три независимых хранилища, обеспечивающие гибкую политику управления объектами и эффективное использование ресурсов памяти:

1. Первый уровень (Strong-LRU Cache):
- Основан на классической LRU (Least Recently Used)-стратегии.
- Элементы сохраняются с сильными ссылками.
- В случае превышения установленного лимита по размеру самый редко используемый объект вытесняется на следующий уровень.
2. Второй уровень (Soft-LRU Cache):
- Представляет собой LRU-кеш с мягкой семантикой ссылок (SoftReference).
- Перемещение объектов сюда происходит автоматически при превышении лимита первого уровня.
- Емкость второго уровня ограничена, и при полном заполнении наименее востребованные объекты отправляются на третий уровень.
3. Третий уровень (Weak-Cache):
- Третий уровень основан на слабых ссылках (WeakReference), обеспечивающих мягкое управление памятью.
- Данные сохраняются в обычном HashMap, но их очистка контролируется системой сборки мусора (GC).
- При нехватке памяти объекты удаляются автоматически, предотвращая возникновение утечек.


Такая многослойная структура направлена на достижение следующих целей:

- Сокращение среднего времени доступа к объектам за счет расширения общей емкости кеша.
- Управление памятью путем автоматического освобождения ресурсов при участии механизмов сборки мусора, что минимизирует риск утечки памяти и повышает эффективность утилизации ресурсов.

## Экспериментальное подтверждение эффективности
Для оценки реальной пользы предлагаемой архитектуры проведены эксперименты, имитирующие реальную рабочую нагрузку на систему. Тесты проводились с учетом дополнительной оптимизации:

- Прогрев виртуальной машины Java (разогрев профилей JIT-компиляции).
- Многократные измерения внутри итераций для уменьшения влияния посторонних факторов.

Эксперименты позволили сравнить трехуровневый кэш с традиционным LRU-кешем, измеряя ключевые показатели:

- Время выполнения операций.
- Потребление оперативной памяти.

# Результаты сравнения производительности различных кешей

Итоговым результатом проведенного тестирования стало понимание ключевой идеи: производительность различных реализаций кэшей определяется конфигурационными параметрами и особенностями эксплуатации.

Например, если трехуровневый кэш сделан достаточно емким, а параметр удерживаемых сильных ссылок на изображения (TEMPORARY_IMAGE_REFERENCE_HOLD_COUNT) увеличен, такой подход обеспечивает высокую производительность, но неизбежно ведет к большему потреблению памяти. Обратная сторона медали проявляется, если параметр TEMPORARY_IMAGE_REFERENCE_HOLD_COUNT уменьшен, а первый и второй уровни трехуровневого кэша сделаны небольшими по размеру: в этом случае сокращается расход памяти, но возрастает время обработки запросов GET. Причиной этого является повышенный трафик перемещения изображений между уровнями кэша, что потенциально приводит к чистке объектов сборщиком мусора (GC) и последующему повторному запросу изображения из внешнего источника.

Таким образом, однозначное утверждение о превосходстве той или иной схемы невозможно сформулировать вне привязки к характеристикам конкретного приложения. Реалистичную оценку целесообразней проводить на реальном приложении, фокусируясь на ключевых аспектах оптимизации.

Тем не менее, при помощи специально подготовленного кода можно моделировать рабочие условия и наблюдать реакцию кэшей на изменение параметров. Например, в моделируемом приложении с крупной коллекцией изображений, активной нагрузкой на операцию GET и ограниченной постоянной ссылкой на изображения, можно рекомендовать увеличить емкость первого уровня трехуровневого кэша, чтобы снизить частоту обращений к внешним источникам данных и, соответственно, повысить производительность.

Я запустила тестирование для этих условий и получила, что действительно, если следовать этим рекомендациями, то трехуровневый кеш выдает примерно то же время для операции get, как обычный, при этом объем расходуемой памяти сокращается:

```
===> Трёхуровневый кэш:
Среднее время работы операции get: 0,51 мс
Количество непустых изображений в кеше с мягкими ссылками: 500
Количество непустых изображений в кеше со слабыми ссылками: 1516
======= Состояние памяти после работы  трёхуровневый кеша ======
Тип области памяти: G1 Eden Space
Тип памяти: Heap memory
Объем занятой памяти: 0 МБ
Выделено памяти: 2 МБ
Максимальная разрешенная память: -0 МБ
Тип области памяти: G1 Old Gen
Тип памяти: Heap memory
Объем занятой памяти: 3,5 МБ
Выделено памяти: 7 МБ
Максимальная разрешенная память: 64 МБ
Сборщик мусора: G1 Young Generation
Кол-во выполненных сборок: 8
Суммарное время работы: 28 мс
Сборщик мусора: G1 Concurrent GC
Кол-во выполненных сборок: 2
Суммарное время работы: 4 мс
Сборщик мусора: G1 Old Generation
Кол-во выполненных сборок: 1
Суммарное время работы: 8 мс

===> Одноуровневый кэш:
Среднее время работы операции get: 0,49 мс
======= Состояние памяти после работы обычного кеша ======
Тип области памяти: G1 Eden Space
Тип памяти: Heap memory
Объем занятой памяти: 0 МБ
Выделено памяти: 2 МБ
Максимальная разрешенная память: -0 МБ
Тип области памяти: G1 Old Gen
Тип памяти: Heap memory
Объем занятой памяти: 6 МБ
Выделено памяти: 9 МБ
Максимальная разрешенная память: 64 МБ
Сборщик мусора: G1 Young Generation
Кол-во выполненных сборок: 16
Суммарное время работы: 63 мс
Сборщик мусора: G1 Concurrent GC
Кол-во выполненных сборок: 6
Суммарное время работы: 14 мс
Сборщик мусора: G1 Old Generation
Кол-во выполненных сборок: 1
Суммарное время работы: 8 мс
```

Из занимательного по отчету выше можно увидеть, что часть изображений из 3 уровня действительно была удалено в ходе сборки мусора: количество изображений в нем составило 1516, в то время как всего изображений было добавлено 10_000.
При этом первый уровень, размерность которого была ограничена в этом тесте 500-ами изображениями, заполнен полностью. Тут, скорее всего, нехватки памяти не было, поэтому сборщик мусора не стал удалять объекты по soft ссылкам.